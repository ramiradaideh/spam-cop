// package main

// import (
// 	"k8s.io/client-go/kubernetes"
// 	"k8s.io/client-go/tools/clientcmd"
// 	"k8s.io/client-go/dynamic"
// 	"k8s.io/apimachinery/pkg/runtime"
// 	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
// 	"k8s.io/apimachinery/pkg/util/yaml"
// )

// func getClientset() *kubernetes.Clientset {
// 	config, err := clientcmd.BuildConfigFromFlags("", "/path/to/kubeconfig") // Use default kubeconfig
// 	if err != nil {
// 		panic(err.Error())
// 	}

// 	clientset, err := kubernetes.NewForConfig(config)
// 	if err != nil {
// 		panic(err.Error())
// 	}
// // 
// 	return clientset
// }

// func decodeKubernetesResource(data []byte) *unstructured.Unstructured {
// 	obj := &unstructured.Unstructured{}
// 	decoder := yaml.NewYAMLOrJSONDecoder(data, 100)
// 	if err := decoder.Decode(&obj.Object); err != nil {
// 		panic(err)
// 	}
// 	return obj
// }

// func applyResource(clientset *kubernetes.Clientset, obj *unstructured.Unstructured, namespace string) error {
// 	// You can customize this method to handle dynamic resource application.
// 	// For example:
// 	dynClient, err := dynamic.NewForConfig(getClientset().RESTConfig())
// 	resource := dynClient.Resource(...) // pass GVR here
// 	resource.Namespace(namespace).Update(context.TODO(), obj, metav1.UpdateOptions{})
// }
